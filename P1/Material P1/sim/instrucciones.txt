Address     Code        Basic                        Line Source

0x00400000  0x0fc10417  auipc x8,0x0000fc10          28   	auipc s0,0x0000fc10
0x00400004  0x00000013  addi x0,x0,0                 29   	nop
0x00400008  0x00000013  addi x0,x0,0                 30   	nop
0x0040000c  0x00040413  addi x8,x8,0                 31   	addi s0,s0,0
0x00400010  0x0fc10497  auipc x9,0x0000fc10          33   	auipc s1,0x0000fc10 
0x00400014  0x00000013  addi x0,x0,0                 34   	nop
0x00400018  0x00000013  addi x0,x0,0                 35   	nop
0x0040001c  0x01848493  addi x9,x9,24                36   	addi s1,s1,0x00000018
0x00400020  0x00000513  addi x10,x0,0                37   	li a0, 0 # Carga 0 en A0, donde guardaremos el valor del nuevo array (Redundante)
0x00400024  0x00000593  addi x11,x0,0                38   	li a1, 0 # Inicializa el recorrido del array (Redundante)
0x00400028  0x02800913  addi x18,x0,0x00000028       40   	li s2, 40 # Limite del array (10*4)
0x0040002c  0xfff00993  addi x19,x0,0xffffffff       41   	addi s3, zero, -1 # 0xFFFF, para utilizar para hacer Complemento A1 con XOR
0x00400030  0x00100a13  addi x20,x0,1                42   	addi s4, zero, 1 # Usamos un valor constante de uno para usar BGE en el caso x > 0
0x00400034  0x01e402b3  add x5,x8,x30                47   		add t0, s0, t5 #Calculamos posicion de memoria
0x00400038  0x0002a303  lw x6,0(x5)                  48   		lw t1, 0(t0) #Cargamos en T1 el valor de nums al que se ha accedido 
0x0040003c  0x013343b3  xor x7,x6,x19                49   		xor t2, t1, s3 #Complemento A1
0x00400040  0x00000013  addi x0,x0,0                 50   		nop
0x00400044  0x00000013  addi x0,x0,0                 51   		nop
0x00400048  0x00138393  addi x7,x7,1                 52   		addi t2, t2, 1 #Complemento A2
0x0040004c  0x00000013  addi x0,x0,0                 53   		nop
0x00400050  0x00000013  addi x0,x0,0                 54   		nop
0x00400054  0x00750e33  add x28,x10,x7               56   		add t3, a0, t2 #(A0-T2). Es una comparacion
0x00400058  0x00000013  addi x0,x0,0                 57   		nop
0x0040005c  0x00000013  addi x0,x0,0                 58   		nop
0x00400060  0x040e5063  bge x28,x0,0x00000040        59   		bge t3, zero, loop_advance #Salta si T3 es mayor que A0
0x00400064  0x00000013  addi x0,x0,0                 60   		nop
0x00400068  0x00000013  addi x0,x0,0                 61   		nop
0x0040006c  0x00000013  addi x0,x0,0                 62   		nop
0x00400070  0x02060663  beq x12,x0,0x0000002c        66   		beq a2, zero, loop_swapvalue #Si A2 es 0, no hay que comparar.
0x00400074  0x00000013  addi x0,x0,0                 67   		nop
0x00400078  0x00000013  addi x0,x0,0                 68   		nop
0x0040007c  0x00000013  addi x0,x0,0                 69   		nop
0x00400080  0x00760eb3  add x29,x12,x7               70   		add t4, a2, t2 #Compara si A2 < T3
0x00400084  0x00000013  addi x0,x0,0                 71   		nop
0x00400088  0x00000013  addi x0,x0,0                 72   		nop
0x0040008c  0x000eca63  blt x29,x0,0x00000014        73   		blt t4, zero, loop_advance #Salta si A2 > T3
0x00400090  0x00000013  addi x0,x0,0                 74   		nop
0x00400094  0x00000013  addi x0,x0,0                 75   		nop
0x00400098  0x00000013  addi x0,x0,0                 76   		nop
0x0040009c  0x00030633  add x12,x6,x0                80   		add a2, t1, zero #Asignamos el valor en T1 (valor cargado de la lista) a A2 (valor a comparar)	
0x004000a0  0x004f0f13  addi x30,x30,4               83   		addi t5, t5, 4 # Como no podemos usar slli, debemos añadir 4.
0x004000a4  0x00000013  addi x0,x0,0                 84   		nop
0x004000a8  0x00000013  addi x0,x0,0                 85   		nop
0x004000ac  0xf92f14e3  bne x30,x18,0xffffff88       86   		bne t5, s2, loop_read # Comparamos con 40
0x004000b0  0x00000013  addi x0,x0,0                 87   		nop
0x004000b4  0x00000013  addi x0,x0,0                 88   		nop
0x004000b8  0x00000013  addi x0,x0,0                 89   		nop
0x004000bc  0x00b482b3  add x5,x9,x11                92   		add t0, s1, a1 #Calcula la direccion de escritura
0x004000c0  0x00000013  addi x0,x0,0                 93   		nop
0x004000c4  0x00000013  addi x0,x0,0                 94   		nop
0x004000c8  0x00c2a023  sw x12,0(x5)                 95   		sw a2, 0(t0) #Guarda el valor en la posicion del array correspondiente
0x004000cc  0x00458593  addi x11,x11,4               96   		addi a1, a1, 4 #Añade "1" (4) al contador de escritura
0x004000d0  0x00000013  addi x0,x0,0                 97   		nop
0x004000d4  0x00000013  addi x0,x0,0                 98   		nop
0x004000d8  0x03258663  beq x11,x18,0x0000002c       99   		beq a1, s2, end #Comparamos con 40
0x004000dc  0x00000013  addi x0,x0,0                 100  		nop
0x004000e0  0x00000013  addi x0,x0,0                 101  		nop
0x004000e4  0x00000013  addi x0,x0,0                 102  		nop
0x004000e8  0x00000f33  add x30,x0,x0                103  		add t5, zero, zero #Resetea el contador de recorrido del array num a 0. En esta seccion, no necesitamos NOP
0x004000ec  0x00060533  add x10,x12,x0               104  		add a0, a2, zero #Asignamos A2 (i) el valor de last (A0)
0x004000f0  0x00000633  add x12,x0,x0                105  		add a2, zero, zero #Reseteamos A2
0x004000f4  0xf41ff06f  jal x0,0xffffff40            106  		j loop_read #Reiniciamos el programa
0x004000f8  0x00000013  addi x0,x0,0                 107          	nop
0x004000fc  0x00000013  addi x0,x0,0                 108          	nop
0x00400100  0x00000013  addi x0,x0,0                 109          	nop
